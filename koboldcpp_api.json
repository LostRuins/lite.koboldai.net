{
	"components": {
		"schemas": {
			"BasicError": {
				"properties": {
					"msg": {
						"type": "string"
					},
					"type": {
						"type": "string"
					}
				},
				"required": [
					"msg",
					"type"
				],
				"type": "object"
			},
			"BasicResult": {
				"properties": {
					"result": {
						"$ref": "#/components/schemas/BasicResultInner"
					}
				},
				"required": [
					"result"
				],
				"type": "object"
			},
			"BasicResultInner": {
				"properties": {
					"result": {
						"type": "string"
					}
				},
				"required": [
					"result"
				],
				"type": "object"
			},
			"GenerationInput": {
				"properties": {
					"max_context_length": {
						"description": "Maximum number of tokens to send to the model.",
						"minimum": 1,
						"type": "integer"
					},
					"max_length": {
						"description": "Number of tokens to generate.",
						"minimum": 1,
						"type": "integer"
					},
					"prompt": {
						"description": "This is the submission.",
						"type": "string"
					},
					"rep_pen": {
						"description": "Base repetition penalty value.",
						"minimum": 1,
						"type": "number"
					},
					"rep_pen_range": {
						"description": "Repetition penalty range.",
						"minimum": 0,
						"type": "integer"
					},
					"sampler_order": {
						"description": "Sampler order to be used. If N is the length of this array, then N must be greater than or equal to 6 and the array must be a permutation of the first N non-negative integers.",
						"items": {
							"type": "integer"
						},
						"minItems": 6,
						"type": "array"
					},
					"sampler_seed": {
						"description": "RNG seed to use for sampling. If not specified, the global RNG will be used.",
						"maximum": 999999,
						"minimum": 1,
						"type": "integer"
					},
					"stop_sequence": {
						"description": "An array of string sequences where the API will stop generating further tokens. The returned text WILL contain the stop sequence if trim_stop is false.",
						"items": {
							"type": "string"
						},
						"type": "array"
					},
					"temperature": {
						"description": "Temperature value.",
						"minimum": 0,
						"type": "number"
					},
					"tfs": {
						"description": "Tail free sampling value.",
						"maximum": 1,
						"minimum": 0,
						"type": "number"
					},
					"top_a": {
						"description": "Top-a sampling value.",
						"minimum": 0,
						"type": "number"
					},
					"top_k": {
						"description": "Top-k sampling value.",
						"minimum": 0,
						"type": "integer"
					},
					"top_p": {
						"description": "Top-p sampling value.",
						"maximum": 1,
						"minimum": 0,
						"type": "number"
					},
					"min_p": {
						"description": "Min-p sampling value.",
						"maximum": 1,
						"minimum": 0,
						"type": "number"
					},
					"typical": {
						"description": "Typical sampling value.",
						"maximum": 1,
						"minimum": 0,
						"type": "number"
					},
					"use_default_badwordsids": {
						"default": false,
						"description": "If true, prevents the EOS token from being generated (Ban EOS).",
						"type": "boolean"
					},
					"dynatemp_range": {
						"default": 0,
						"description": "If not equal to 0, uses dynamic temperature. Dynamic temperature range will be between Temp+Range and Temp-Range. If equal to 0 , uses static temperature.",
						"minimum": -5,
						"maximum": 5,
						"type": "number"
					},
					"smoothing_factor": {
						"default": 0,
						"description": "Modifies temperature behavior. If greater than 0 uses smoothing factor.",
						"minimum": 0,
						"type": "number"
					},
					"dynatemp_exponent": {
						"default": 1,
						"description": "Exponent used in dynatemp.",
						"type": "number"
					},
					"mirostat": {
						"description": "KoboldCpp ONLY. Sets the mirostat mode, 0=disabled, 1=mirostat_v1, 2=mirostat_v2",
						"minimum": 0,
						"maximum": 2,
						"type": "number"
					},
					"mirostat_tau": {
						"description": "KoboldCpp ONLY. Mirostat tau value.",
						"minimum": 0,
						"type": "number"
					},
					"mirostat_eta": {
						"description": "KoboldCpp ONLY. Mirostat eta value.",
						"minimum": 0,
						"type": "number"
					},
					"genkey": {
						"description": "KoboldCpp ONLY. A unique genkey set by the user. When checking a polled-streaming request, use this key to be able to fetch pending text even if multiuser is enabled.",
						"type": "string"
					},
					"grammar": {
						"description": "KoboldCpp ONLY. A string containing the GBNF grammar to use.",
						"type": "string"
					},
					"grammar_retain_state": {
						"default": false,
						"description": "KoboldCpp ONLY. If true, retains the previous generation's grammar state, otherwise it is reset on new generation.",
						"type": "boolean"
					},
					"memory": {
						"description": "KoboldCpp ONLY. If set, forcefully appends this string to the beginning of any submitted prompt text. If resulting context exceeds the limit, forcefully overwrites text from the beginning of the main prompt until it can fit. Useful to guarantee full memory insertion even when you cannot determine exact token count.",
						"type": "string"
					},
					"images": {
						"description": "KoboldCpp ONLY. If set, takes an array of base64 encoded strings, each one representing an image to be processed.",
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"trim_stop": {
						"default": true,
						"description": "KoboldCpp ONLY. If true, also removes detected stop_sequences from the output and truncates all text after them. If false, output will also include stop sequence and potentially a few additional characters.",
						"type": "boolean"
					},
					"render_special": {
						"default": false,
						"description": "KoboldCpp ONLY. If true, prints special tokens as text for GGUF models",
						"type": "boolean"
					},
					"bypass_eos": {
						"default": false,
						"description": "KoboldCpp ONLY. If true, allows EOS token to be generated, but does not stop generation. Not recommended unless you know what you are doing.",
						"type": "boolean"
					},
					"banned_tokens": {
						"description": "An array of string sequences, each entry represents a word or phrase prevented from being generated, either modifying model vocab or by backtracking and regenerating when they appear.",
						"items": {
							"type": "string"
						},
						"type": "array"
					},
					"logit_bias": {
						"default": {},
						"description": "KoboldCpp ONLY. An dictionary of key-value pairs, which indicate the token IDs (int) and logit bias (float) to apply for that token. Up to 16 value can be provided.",
						"type": "object",
						"example": {
							"2": -20,
							"145": -1.4,
							"3105": 3.2
						}
					},
					"dry_multiplier": {
						"description": "KoboldCpp ONLY. DRY multiplier value, 0 to disable.",
						"minimum": 0,
						"type": "number"
					},
					"dry_base": {
						"description": "KoboldCpp ONLY. DRY base value.",
						"minimum": 0,
						"type": "number"
					},
					"dry_allowed_length": {
						"description": "KoboldCpp ONLY. DRY allowed length value.",
						"minimum": 0,
						"type": "number"
					},
					"dry_sequence_breakers": {
						"description": "An array of string sequence breakers for DRY.",
						"items": {
							"type": "string"
						},
						"type": "array"
					},
					"xtc_threshold": {
						"description": "KoboldCpp ONLY. XTC threshold.",
						"minimum": 0,
						"type": "number"
					},
					"xtc_probability": {
						"description": "KoboldCpp ONLY. XTC probability. Set to above 0 to enable XTC.",
						"minimum": 0,
						"type": "number"
					},
					"logprobs": {
						"default": false,
						"description": "If true, return up to 5 top logprobs for generated tokens. Incurs performance overhead.",
						"type": "boolean"
					}
				},
				"required": [
					"prompt"
				],
				"type": "object"
			},
			"GenerationOutput": {
				"properties": {
					"results": {
						"description": "Array of generated outputs.",
						"items": {
							"$ref": "#/components/schemas/GenerationResult"
						},
						"type": "array"
					}
				},
				"required": [
					"results"
				],
				"type": "object"
			},
			"GenerationResult": {
				"properties": {
					"text": {
						"description": "Generated output as plain text.",
						"type": "string"
					}
				},
				"required": [
					"text"
				],
				"type": "object"
			},
			"MaxContextLengthSetting": {
				"properties": {
					"value": {
						"minimum": 8,
						"type": "integer"
					}
				},
				"required": [
					"value"
				],
				"type": "object"
			},
			"MaxLengthSetting": {
				"properties": {
					"value": {
						"minimum": 1,
						"type": "integer"
					}
				},
				"required": [
					"value"
				],
				"type": "object"
			},
			"ServerBusyError": {
				"properties": {
					"detail": {
						"$ref": "#/components/schemas/BasicError"
					}
				},
				"required": [
					"detail"
				],
				"type": "object"
			},
			"ValueResult": {
				"properties": {
					"value": {
						"type": "integer"
					}
				},
				"required": [
					"value"
				],
				"type": "object"
			},
			"KcppVersion": {
				"properties": {
					"result": {
						"type": "string"
					},
					"version": {
						"type": "string"
					}
				},
				"required": [
					"version"
				],
				"type": "object"
			},
			"KcppPerf": {
				"properties": {
					"last_process": {
						"type": "number",
						"description": "Last processing time in seconds."
					},
					"last_eval": {
						"type": "number",
						"description": "Last evaluation time in seconds."
					},
					"last_token_count": {
						"type": "integer",
						"description": "Last token count."
					},
					"last_seed": {
						"type": "integer",
						"description": "Last generation seed used."
					},
					"last_draft_success": {
						"type": "integer",
						"description": "Last generation draft successes in tokens."
					},
					"last_draft_failed": {
						"type": "integer",
						"description": "Last generation draft failures in tokens."
					},
					"total_gens": {
						"type": "integer",
						"description": "Total requests generated since startup."
					},
					"total_img_gens": {
						"type": "integer",
						"description": "Total image requests generated since startup."
					},
					"total_tts_gens": {
						"type": "integer",
						"description": "Total tts requests generated since startup."
					},
					"total_transcribe_gens": {
						"type": "integer",
						"description": "Total transcribe requests generated since startup."
					},
					"stop_reason": {
						"type": "integer",
						"description": "Reason the generation stopped. INVALID=-1, OUT_OF_TOKENS=0, EOS_TOKEN_HIT=1, CUSTOM_STOPPER=2"
					},
					"queue": {
						"type": "integer",
						"description": "Length of generation queue."
					},
					"idle": {
						"type": "integer",
						"description": "Status of backend, busy or idle."
					},
					"hordeexitcounter": {
						"type": "integer",
						"description": "Status of embedded horde worker, if applicable. If it's too high, may have crashed."
					},
					"uptime": {
						"type": "integer",
						"description": "Seconds that the server has been running for."
					},
					"idletime": {
						"type": "integer",
						"description": "Seconds that the server has been inactive for."
					},
					"quiet": {
						"type": "boolean",
						"description": "Is the server in quiet (no logging) mode."
					}
				},
				"required": [
					"version"
				],
				"type": "object"
			}
		}
	},
	"info": {
		"title": "KoboldCpp API",
		"description": "For swagger.json, <a href=\"?json=1\">click here</a> or use <a href=\"https://lite.koboldai.net/koboldcpp_api.json\">online version</a>.",
		"version": "2025.06.03"
	},
	"openapi": "3.0.3",
	"paths": {
		"/api/v1/config/max_context_length": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"value": 2048
								},
								"schema": {
									"$ref": "#/components/schemas/MaxContextLengthSetting"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Retrieve the current max context length setting value that public backends see",
				"tags": [
					"api/v1"
				]
			}
		},
		"/api/v1/config/max_length": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"value": 80
								},
								"schema": {
									"$ref": "#/components/schemas/MaxLengthSetting"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Retrieve the current max length (amount to generate) setting value",
				"tags": [
					"api/v1"
				]
			}
		},
		"/api/v1/generate": {
			"post": {
				"description": "Generates text given a prompt and generation settings.\n\nUnspecified values are set to defaults.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"max_context_length": 2048,
								"max_length": 100,
								"prompt": "Niko the kobold stalked carefully down the alley, his small scaly figure obscured by a dusky cloak that fluttered lightly in the cold winter breeze.",
								"quiet": false,
								"rep_pen": 1.1,
								"rep_pen_range": 256,
								"rep_pen_slope": 1,
								"temperature": 0.5,
								"tfs": 1.0,
								"top_a": 0,
								"top_k": 100,
								"top_p": 0.9,
								"typical": 1.0
							},
							"schema": {
								"$ref": "#/components/schemas/GenerationInput"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"results": [
										{
											"text": " Holding up his tail to keep it from dragging in the dirty snow that covered the cobblestone, he waited patiently for the butcher to turn his attention from his stall so that he could pilfer his next meal: a tender-looking chicken."
										}
									]
								},
								"schema": {
									"$ref": "#/components/schemas/GenerationOutput"
								}
							}
						},
						"description": "Successful request"
					},
					"503": {
						"content": {
							"application/json": {
								"example": {
									"detail": {
										"msg": "Server is busy; please try again later.",
										"type": "service_unavailable"
									}
								},
								"schema": {
									"$ref": "#/components/schemas/ServerBusyError"
								}
							}
						},
						"description": "Server is busy"
					}
				},
				"summary": "Generate text with a specified prompt",
				"tags": [
					"api/v1"
				]
			}
		},
		"/api/v1/info/version": {
			"get": {
				"description": "Returns the matching *KoboldAI* (United) version of the API that you are currently using. This is not the same as the KoboldCpp API version - this is used to feature match against KoboldAI United.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"result": "1.2.5"
								},
								"schema": {
									"$ref": "#/components/schemas/BasicResult"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Current KoboldAI United API version",
				"tags": [
					"api/v1"
				]
			}
		},
		"/api/v1/model": {
			"get": {
				"description": "Gets the current model display name.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"result": "koboldcpp/airoboros-l2-7b-2.2"
								},
								"schema": {
									"$ref": "#/components/schemas/BasicResult"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Retrieve the current model string.",
				"tags": [
					"api/v1"
				]
			}
		},
		"/api/extra/true_max_context_length": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"value": 2048
								},
								"schema": {
									"$ref": "#/components/schemas/MaxContextLengthSetting"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Retrieve the actual max context length setting value set from the launcher",
				"description": "Retrieve the actual max context length setting value set from the launcher",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/version": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"result": "KoboldCpp",
									"version": "2025.06.03",
									"protected": false,
									"txt2img": false,
									"vision": false,
									"transcribe": false,
									"multiplayer": false,
									"websearch": false,
									"tts": false,
									"embeddings": false
								},
								"schema": {
									"$ref": "#/components/schemas/KcppVersion"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Retrieve the KoboldCpp backend version",
				"summary": "Retrieve the KoboldCpp backend version",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/preloadstory": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"prompt": "Hello world",
									"memory": "Some text",
									"authorsnote": "",
									"actions": []
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Retrieves the KoboldCpp preloaded story, --preloadstory configures a prepared story json save file to be hosted on the server, which frontends (such as KoboldAI Lite) can access over the API.",
				"summary": "Retrieves the KoboldCpp preloaded story",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/perf": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"last_process": 0.76,
									"last_eval": 65.8,
									"last_token_count": 26,
									"last_seed": 427343,
									"last_draft_success": 0,
									"last_draft_failed": 0,
									"total_gens": 1724,
									"stop_reason": 0,
									"total_img_gens": 0,
									"total_tts_gens": 0,
									"total_transcribe_gens": 0,
									"queue": 0,
									"idle": 0,
									"hordeexitcounter": -1,
									"uptime": 2255,
									"idletime": 3.5,
									"quiet": true
								},
								"schema": {
									"$ref": "#/components/schemas/KcppPerf"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Retrieve the KoboldCpp recent performance information",
				"summary": "Retrieve the KoboldCpp recent performance information",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/multiplayer/status": {
			"post": {
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"sender": "KCPP_1234",
								"senderbusy": true
							},
							"schema": {
								"properties": {
									"senderbusy": {
										"type": "boolean"
									},
									"sender": {
										"type": "string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"turn_major": 0,
									"turn_minor": 0,
									"idle": 1,
									"data_format": ""
								},
								"schema": {
									"properties": {
										"turn_major": {
											"type": "string"
										},
										"turn_minor": {
											"type": "string"
										},
										"idle": {
											"type": "number"
										},
										"data_format": {
											"type": "string"
										}
									},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Fetches the current multiplayer turn information. Only useful for Multiplayer sessions in KoboldAI Lite.",
				"summary": "Fetches the current multiplayer turn information.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/multiplayer/getstory": {
			"post": {
				"responses": {
					"200": {
						"content": {
							"text/plain": {
								"schema": {
									"type": "string",
									"example": "base64_lzma_str"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Fetches the current multiplayer story data, LZMA compressed encoded base64. Data is usually in the same format is KAI Lite compressed savefiles.",
				"summary": "Fetches the current multiplayer story data, LZMA compressed encoded base64",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/multiplayer/setstory": {
			"post": {
				"description": "Sets the current multiplayer story and increments the turn.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"full_update": true,
								"sender": "LITE_UID_123456",
								"data_format": "kcpp_lzma_b64",
								"data": "base64_lzma_str"
							},
							"schema": {
								"properties": {
									"full_update": {
										"type": "boolean"
									},
									"sender": {
										"type": "string"
									},
									"data_format": {
										"type": "string"
									},
									"data": {
										"type": "string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"results": [
										{
											"success": true,
											"turn_major": 1,
											"turn_minor": 0,
											"idle": 1,
											"data_format": ""
										}
									]
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean"
										},
										"turn_major": {
											"type": "string"
										},
										"turn_minor": {
											"type": "string"
										},
										"idle": {
											"type": "number"
										},
										"data_format": {
											"type": "string"
										}
									},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Sets the current multiplayer story and increments the turn.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/generate/stream": {
			"post": {
				"description": "Generates text given a prompt and generation settings, with SSE streaming.\n\nUnspecified values are set to defaults.\n\nSSE streaming establishes a persistent connection, returning ongoing process in the form of message events.\n\n``` \nevent: message\ndata: {data}\n\n```",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"prompt": "Niko the kobold stalked carefully down the alley, his small scaly figure obscured by a dusky cloak that fluttered lightly in the cold winter breeze.",
								"temperature": 0.5,
								"top_p": 0.9
							},
							"schema": {
								"$ref": "#/components/schemas/GenerationInput"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"results": [
										{
											"text": " Holding up his tail to keep it from dragging in the dirty snow that covered the cobblestone, he waited patiently for the butcher to turn his attention from his stall so that he could pilfer his next meal: a tender-looking chicken."
										}
									]
								},
								"schema": {
									"$ref": "#/components/schemas/GenerationOutput"
								}
							}
						},
						"description": "Successful request"
					},
					"503": {
						"content": {
							"application/json": {
								"example": {
									"detail": {
										"msg": "Server is busy; please try again later.",
										"type": "service_unavailable"
									}
								},
								"schema": {
									"$ref": "#/components/schemas/ServerBusyError"
								}
							}
						},
						"description": "Server is busy"
					}
				},
				"summary": "Generate text with a specified prompt. SSE streamed results.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/generate/check": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"results": [
										{
											"text": ", my name is Nik"
										}
									]
								},
								"schema": {
									"$ref": "#/components/schemas/GenerationOutput"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Poll the incomplete results of the currently ongoing text generation.",
				"description": "Poll the incomplete results of the currently ongoing text generation. Will not work when multiple requests are in queue.",
				"tags": [
					"api/extra"
				]
			},
			"post": {
				"description": "Poll the incomplete results of the currently ongoing text generation. A unique genkey previously submitted allows polling even in multiuser mode.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"genkey": "KCPP2342"
							},
							"schema": {
								"properties": {
									"genkey": {
										"type": "string",
										"description": "A unique key used to identify this generation while it is in progress."
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"results": [
										{
											"text": ", my name is Nik"
										}
									]
								},
								"schema": {
									"$ref": "#/components/schemas/GenerationOutput"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Poll the incomplete results of the currently ongoing text generation. Supports multiuser mode.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/last_logprobs": {
			"post": {
				"description": "Obtains the token logprobs of the most recent request. A unique genkey previously submitted is required in multiuser mode.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"genkey": "KCPP2342"
							},
							"schema": {
								"properties": {
									"genkey": {
										"type": "string",
										"description": "A unique key used to identify the previous generation."
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"logprobs": {
										"content": [
											{
												"token": "Hello",
												"logprob": -0.31725305,
												"bytes": [
													72,
													101,
													108,
													108,
													111
												],
												"top_logprobs": [
													{
														"token": "Hello",
														"logprob": -0.31725305,
														"bytes": [
															72,
															101,
															108,
															108,
															111
														]
													},
													{
														"token": "Hi",
														"logprob": -1.3190403,
														"bytes": [
															72,
															105
														]
													}
												]
											},
											{
												"token": "!",
												"logprob": -0.02380986,
												"bytes": [
													33
												],
												"top_logprobs": [
													{
														"token": "!",
														"logprob": -0.02380986,
														"bytes": [
															33
														]
													},
													{
														"token": " there",
														"logprob": -3.787621,
														"bytes": [
															32,
															116,
															104,
															101,
															114,
															101
														]
													}
												]
											},
											{
												"token": " How",
												"logprob": -0.000054669687,
												"bytes": [
													32,
													72,
													111,
													119
												],
												"top_logprobs": [
													{
														"token": " How",
														"logprob": -0.000054669687,
														"bytes": [
															32,
															72,
															111,
															119
														]
													},
													{
														"token": "<|end|>",
														"logprob": -10.953937,
														"bytes": null
													}
												]
											},
											{
												"token": " can",
												"logprob": -0.015801601,
												"bytes": [
													32,
													99,
													97,
													110
												],
												"top_logprobs": [
													{
														"token": " can",
														"logprob": -0.015801601,
														"bytes": [
															32,
															99,
															97,
															110
														]
													},
													{
														"token": " may",
														"logprob": -4.161023,
														"bytes": [
															32,
															109,
															97,
															121
														]
													}
												]
											},
											{
												"token": " I",
												"logprob": -0.0000037697225,
												"bytes": [
													32,
													73
												],
												"top_logprobs": [
													{
														"token": " I",
														"logprob": -0.0000037697225,
														"bytes": [
															32,
															73
														]
													},
													{
														"token": " assist",
														"logprob": -13.596657,
														"bytes": [
															32,
															97,
															115,
															115,
															105,
															115,
															116
														]
													}
												]
											},
											{
												"token": " assist",
												"logprob": -0.04571125,
												"bytes": [
													32,
													97,
													115,
													115,
													105,
													115,
													116
												],
												"top_logprobs": [
													{
														"token": " assist",
														"logprob": -0.04571125,
														"bytes": [
															32,
															97,
															115,
															115,
															105,
															115,
															116
														]
													},
													{
														"token": " help",
														"logprob": -3.1089056,
														"bytes": [
															32,
															104,
															101,
															108,
															112
														]
													}
												]
											},
											{
												"token": " you",
												"logprob": -0.0000054385737,
												"bytes": [
													32,
													121,
													111,
													117
												],
												"top_logprobs": [
													{
														"token": " you",
														"logprob": -0.0000054385737,
														"bytes": [
															32,
															121,
															111,
															117
														]
													},
													{
														"token": " today",
														"logprob": -12.807695,
														"bytes": [
															32,
															116,
															111,
															100,
															97,
															121
														]
													}
												]
											},
											{
												"token": " today",
												"logprob": -0.0040071653,
												"bytes": [
													32,
													116,
													111,
													100,
													97,
													121
												],
												"top_logprobs": [
													{
														"token": " today",
														"logprob": -0.0040071653,
														"bytes": [
															32,
															116,
															111,
															100,
															97,
															121
														]
													},
													{
														"token": "?",
														"logprob": -5.5247097,
														"bytes": [
															63
														]
													}
												]
											},
											{
												"token": "?",
												"logprob": -0.0008108172,
												"bytes": [
													63
												],
												"top_logprobs": [
													{
														"token": "?",
														"logprob": -0.0008108172,
														"bytes": [
															63
														]
													},
													{
														"token": "?\n",
														"logprob": -7.184561,
														"bytes": [
															63,
															10
														]
													}
												]
											}
										]
									}
								},
								"schema": {
									"properties": {
										"logprobs": {
											"type": "object",
											"description": "A logprobs object in the same format as OpenAI API."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Obtains the token logprobs of the most recent request.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/tokencount": {
			"post": {
				"description": "Counts the number of tokens in a string, and returns their token IDs. Also aliased to /api/extra/tokenize",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"prompt": "Hello, my name is Niko."
							},
							"schema": {
								"properties": {
									"prompt": {
										"type": "string",
										"description": "The string to be tokenized."
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"value": 9,
									"ids": [
										1,
										22557,
										28725,
										586,
										1141,
										349,
										11952,
										28709,
										28723
									]
								},
								"schema": {
									"properties": {
										"value": {
											"type": "number"
										},
										"ids": {
											"type": "array",
											"items": {
												"type": "integer"
											}
										}
									},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Counts the number of tokens in a string.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/detokenize": {
			"post": {
				"description": "Converts an array of token IDs into a string.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"ids": [
									529,
									29989,
									5205,
									29989,
									29958,
									13
								]
							},
							"schema": {
								"properties": {
									"ids": {
										"type": "array",
										"items": {
											"type": "number"
										}
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"result": "<|system|>\n",
									"success": true
								},
								"schema": {
									"properties": {
										"result": {
											"type": "string",
											"description": "The detokenized string."
										},
										"success": {
											"type": "boolean"
										}
									},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Converts an array of token IDs into a string.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/abort": {
			"post": {
				"description": "Aborts the currently ongoing text generation. Does not work when multiple requests are in queue.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"genkey": "KCPP2342"
							},
							"schema": {
								"properties": {
									"genkey": {
										"type": "string",
										"description": "A unique key used to identify this generation while it is in progress."
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the abort was successful."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Aborts the currently ongoing text generation.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/transcribe": {
			"post": {
				"description": "Uses Whisper to perform a Speech-To-Text transcription.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"prompt": "",
								"suppress_non_speech": false,
								"langcode": "en",
								"audio_data": "base64_wav_data"
							},
							"schema": {
								"properties": {
									"audio_data": {
										"type": "string",
										"description": "Base64 respresentation of a 16-bit 16kHz wave file to be transcribed to text."
									},
									"prompt": {
										"type": "string",
										"description": "Prompt to steer the transcription."
									},
									"langcode": {
										"type": "string",
										"description": "Two letter language code, or use auto to autodetect."
									},
									"suppress_non_speech": {
										"type": "boolean",
										"description": "Prevent noise tokens, always generate words for speech."
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"text": "Hello world"
								},
								"schema": {
									"$ref": "#/components/schemas/ValueResult"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Uses Whisper to perform a Speech-To-Text transcription.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/websearch": {
			"post": {
				"description": "Searches the web using DuckDuckGo and returns the top 3 results.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"q": "What is KoboldCpp"
							},
							"schema": {
								"properties": {
									"q": {
										"type": "string",
										"description": "The search query string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": [
									{
										"title": "KoboldCpp Wiki",
										"url": "https://github.com/LostRuins/koboldcpp/wiki",
										"desc": "KoboldCpp is a program to run LLMs",
										"content": "KoboldCpp is a program to run LLMs using GGUF files"
									}
								],
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Searches the web using DuckDuckGo and returns the top 3 results.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/tts": {
			"post": {
				"description": "Creates text-to-speech audio from input text.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"input": "hello world, how are you today?",
								"voice": "kobo",
								"speaker_json": ""
							},
							"schema": {
								"properties": {
									"input": {
										"type": "string",
										"description": "The text to generate audio for. Try to keep it short."
									},
									"voice": {
										"type": "string",
										"description": "The voice to use when generating the audio. You can enter anything you like, a unique speaker will be generated. There are a few preset voices you can use: kobo,cheery,sleepy,shouty,chatty"
									},
									"speaker_json": {
										"type": "string",
										"description": "Custom speaker JSON. More info at https://github.com/LostRuins/koboldcpp/tree/concedo/examples/outetts"
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"audio/wav": {
								"schema": {
									"type": "string",
									"format": "binary"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Creates text-to-speech audio from input text.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/api/extra/embeddings": {
			"post": {
				"summary": "Creates an embedding vector representing the input text. Please refer to OpenAI documentation",
				"description": "Creates an embedding vector representing the input text.\n\nThis is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/embeddings/create](https://platform.openai.com/docs/api-reference/embeddings/create)",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"model": "kcpp",
								"input": "Niko the Kobold is in town today.",
								"truncate": true
							},
							"schema": {
								"properties": {
									"model": {
										"type": "string",
										"description": "Not used, depends on loaded kcpp embeddings model."
									},
									"input": {
										"type": "string",
										"description": "String to convert into embedding vector"
									},
									"truncate": {
										"type": "boolean",
										"description": "If the string is too long, truncate it. Otherwise, exceeding max embedding size will cause the request to fail."
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"api/extra"
				],
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"object": "list",
									"data": [
										{
											"object": "embedding",
											"index": 0,
											"embedding": [
												0.089203,
												0.016367,
												0.062196,
												-0.045898,
												-0.019921
											]
										}
									],
									"model": "embedmodel",
									"usage": {
										"prompt_tokens": 100,
										"total_tokens": 100
									}
								},
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				}
			}
		},
		"/api/extra/json_to_grammar": {
			"post": {
				"summary": "Converts a provided JSON schema into GBNF grammar.",
				"description": "Converts a provided JSON schema into GBNF grammar. Example schema at [https://platform.openai.com/docs/guides/structured-outputs](https://platform.openai.com/docs/guides/structured-outputs)",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"schema": {
									"type": "object",
									"properties": {
										"action_items": {
											"type": "array",
											"items": {
												"type": "object",
												"properties": {
													"description": {
														"type": "string",
														"description": "Description of the action item."
													},
													"due_date": {
														"type": [
															"string",
															"null"
														],
														"description": "Due date for the action item, can be null if not specified."
													},
													"owner": {
														"type": [
															"string",
															"null"
														],
														"description": "Owner responsible for the action item, can be null if not specified."
													}
												},
												"required": [
													"description",
													"due_date",
													"owner"
												],
												"additionalProperties": false
											},
											"description": "List of action items from the meeting."
										}
									},
									"required": [
										"action_items"
									],
									"additionalProperties": false
								}
							},
							"schema": {
								"properties": {
									"schema": {
										"type": "object",
										"description": "JSON schema representing the desired output format."
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"api/extra"
				],
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"result": "action-items ::= \"[\" space (action-items-item (\",\" space action-items-item)*)? \"]\" space\naction-items-item ::= \"{\" space action-items-item-description-kv \",\" space action-items-item-due-date-kv \",\" space action-items-item-owner-kv \"}\" space\naction-items-item-description-kv ::= \"\\\"description\\\"\" space \":\" space string\naction-items-item-due-date ::= string | null\naction-items-item-due-date-kv ::= \"\\\"due_date\\\"\" space \":\" space action-items-item-due-date\naction-items-item-owner ::= string | null\naction-items-item-owner-kv ::= \"\\\"owner\\\"\" space \":\" space action-items-item-owner\naction-items-kv ::= \"\\\"action_items\\\"\" space \":\" space action-items\nchar ::= [^\"\\\\\\x7F\\x00-\\x1F] | [\\\\] ([\"\\\\bfnrt] | \"u\" [0-9a-fA-F]{4})\nnull ::= \"null\" space\nroot ::= \"{\" space action-items-kv \"}\" space\nspace ::= | \" \" | \"\\n\"{1,2} [ \\t]{0,20}\nstring ::= \"\\\"\" char* \"\\\"\" space",
									"success": true
								},
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				}
			}
		},
		"/api/extra/data/save": {
			"post": {
				"description": "Saves data to a slot in a database file in the KoboldCpp server.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"slot": "1",
								"format": "kcpp_lzma_b64",
								"title": "Untitled Story",
								"data": "base64_data"
							},
							"schema": {
								"properties": {
									"slot": {
										"type": "string",
										"description": "Save slot id to save to."
									},
									"format": {
										"type": "string",
										"description": "Save format, not used currently"
									},
									"title": {
										"type": "string",
										"description": "Title of this saved file"
									},
									"data": {
										"type": "string",
										"description": "Save data text string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true,
									"error": ""
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										},
										"error": {
											"type": "string",
											"description": "What went wrong."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Saves data to a slot in a database file in the KoboldCpp server.",
				"tags": [
					"api/extra/data"
				]
			}
		},
		"/api/extra/data/load": {
			"post": {
				"description": "Loads data from a save slot in the database file in the KoboldCpp server.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"slot": "1"
							},
							"schema": {
								"properties": {
									"slot": {
										"type": "string",
										"description": "Save slot id"
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true,
									"data": "base64_data"
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										},
										"data": {
											"type": "string",
											"description": "Text string containing the loaded data from server."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Loads data from a save slot in the database file in the KoboldCpp server.",
				"tags": [
					"api/extra/data"
				]
			}
		},
		"/api/extra/data/list": {
			"post": {
				"description": "List available saved slots from the KoboldCpp server, returns an array of strings containing their titles.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": [
									"Saved Story 1",
									"Saved Story 2",
									"",
									""
								],
								"schema": {
									"type": "array",
									"items": {
										"type": "string"
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "List available saved slots from the KoboldCpp server.",
				"tags": [
					"api/extra/data"
				]
			}
		},
		"/api/admin/list_options": {
			"get": {
				"summary": "List available .kcpps files to load.",
				"description": "List available .kcpps files to load.",
				"tags": [
					"api/admin"
				],
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": [
									"file1.kcpps",
									"file2.kcpps"
								],
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				}
			}
		},
		"/api/admin/reload_config": {
			"post": {
				"description": "Switches the loaded config, along with any settings and model file changes.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"filename": "file1.kcpps"
							},
							"schema": {
								"properties": {
									"filename": {
										"type": "string",
										"description": "Filename of the .kcpps config to be loaded. Any associated files and models will be automatically swapped in."
									}
								},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Switches the currently loaded .kcpps config, and reloads any changed files or models.",
				"tags": [
					"api/admin"
				]
			}
		},
		"/api/admin/check_state": {
			"post": {
				"description": "Gets the number of bytes taken for existing save state, and predicts the bytes required for a new save state.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true,
									"old_state_size": 0,
									"old_tokens": 0,
									"new_state_size": 0,
									"new_tokens": 0
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										},
										"old_state_size": {
											"type": "number",
											"description": "Bytes currently in used for existing save state."
										},
										"old_tokens": {
											"type": "number",
											"description": "How many tokens in currently existing save state."
										},
										"new_state_size": {
											"type": "number",
											"description": "Bytes a new save state is estimated to consume."
										},
										"new_tokens": {
											"type": "number",
											"description": "How many tokens will be stored if a new save state is made."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Gets the number of bytes taken for existing save state, and predicts the bytes required for a new save state.",
				"tags": [
					"api/admin"
				]
			}
		},
		"/api/admin/save_state": {
			"post": {
				"description": "Creates a new KV cache save state in memory. Overwrites any existing saved state.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true,
									"new_state_size": 12345678,
									"new_tokens": 100
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										},
										"new_state_size": {
											"type": "number",
											"description": "Bytes a new save state is estimated to consume."
										},
										"new_tokens": {
											"type": "number",
											"description": "How many context tokens were saved in state."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Creates a new KV cache save state in memory. Overwrites any existing saved state.",
				"tags": [
					"api/admin"
				]
			}
		},
		"/api/admin/load_state": {
			"post": {
				"description": "Reloads a previous KV cache save state into context.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true,
									"new_tokens": 100
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										},
										"new_tokens": {
											"type": "number",
											"description": "How many context tokens were loaded from state."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Reloads a previous KV cache save state into context.",
				"tags": [
					"api/admin"
				]
			}
		},
		"/api/admin/clear_state": {
			"post": {
				"description": "Frees any previous KV cache save state.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Frees any previous KV cache save state.",
				"tags": [
					"api/admin"
				]
			}
		},
		"/api/extra/shutdown": {
			"post": {
				"description": "Shuts down the server and exits koboldcpp. Only usable from localhost! Both old and new KoboldCpp Server must have been launched with the --singleinstance flag for this to work.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"success": true
								},
								"schema": {
									"properties": {
										"success": {
											"type": "boolean",
											"description": "Whether the operation was successful."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Shuts down the current KoboldCpp server.",
				"tags": [
					"api/extra"
				]
			}
		},
		"/props": {
			"get": {
				"summary": "Returns the Jinja template stored in the GGUF model, if found.",
				"description": "Returns the Jinja template stored in the GGUF model, if found.",
				"tags": [
					"serviceinfo"
				],
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"chat_template": "string",
									"total_slots": 1,
									"default_generation_settings": {
										"n_ctx": 2048
									}
								},
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				}
			}
		},
		"/.well-known/serviceinfo": {
			"get": {
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"version": "0.2",
									"software": {
										"name": "KoboldCpp",
										"version": 1.77,
										"repository": "https://github.com/LostRuins/koboldcpp",
										"homepage": "https://github.com/LostRuins/koboldcpp",
										"logo": "https://raw.githubusercontent.com/LostRuins/koboldcpp/refs/heads/concedo/niko.ico"
									},
									"api": {
										"koboldai": {
											"name": "KoboldAI API",
											"rel_url": "/api",
											"documentation": "https://lite.koboldai.net/koboldcpp_api",
											"version": 1.77
										},
										"openai": {
											"name": "OpenAI API",
											"rel_url ": "/v1",
											"documentation": "https://openai.com/documentation/api",
											"version": 1.77
										}
									}
								},
								"schema": {
									"properties": {},
									"type": "object"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"description": "Retrieve the common API identity provider",
				"summary": "Retrieve the common API identity provider",
				"tags": [
					"serviceinfo"
				]
			}
		},
		"/sdapi/v1/sd-models": {
			"get": {
				"description": "Gets a list of image generation models. For koboldcpp, only one model will be returned. If no model is loaded, the list is empty.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": [
									{
										"title": "stable_diffusion",
										"model_name": "stable_diffusion",
										"hash": "8888888888",
										"sha256": "8888888888888888888888888888888888888888888888888888888888888888",
										"filename": "path_to_safetensors_model_file",
										"config": null
									}
								]
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Gets a list of image generation models",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/sdapi/v1/options": {
			"get": {
				"description": "Gets configuration info for image generation, used to get loaded model name in A1111.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"samples_format": "png",
									"sd_model_checkpoint": "stable_diffusion"
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Gets configuration info for image generation",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/sdapi/v1/samplers": {
			"get": {
				"description": "Gets a list of supported samplers.",
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": [
									{
										"name": "Euler a",
										"aliases": [
											"k_euler_a",
											"k_euler_ancestral"
										],
										"options": {}
									},
									{
										"name": "Euler",
										"aliases": [
											"k_euler"
										],
										"options": {}
									},
									{
										"name": "Heun",
										"aliases": [
											"k_heun"
										],
										"options": {}
									},
									{
										"name": "DPM2",
										"aliases": [
											"k_dpm_2"
										],
										"options": {}
									},
									{
										"name": "DPM++ 2M",
										"aliases": [
											"k_dpmpp_2m"
										],
										"options": {}
									}
								]
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Gets a list of supported samplers",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/sdapi/v1/txt2img": {
			"post": {
				"description": "Generates an image from a text prompt, and returns a base64 encoded png.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"prompt": "picture of a kobold, high quality HD render",
								"negative_prompt": "ugly, deformed, censored",
								"cfg_scale": 5,
								"steps": 20,
								"width": 512,
								"height": 512,
								"seed": -1,
								"clip_skip": -1,
								"sampler_name": "Euler a"
							},
							"schema": {
								"properties": {
									"prompt": {
										"type": "string"
									},
									"negative_prompt": {
										"type": "string"
									},
									"cfg_scale": {
										"type": "number"
									},
									"steps": {
										"type": "number"
									},
									"width": {
										"type": "number"
									},
									"height": {
										"type": "number"
									},
									"seed": {
										"type": "number"
									},
									"clip_skip": {
										"type": "number"
									},
									"sampler_name": {
										"type": "string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"images": [
										"base64_image_data"
									],
									"parameters": {},
									"info": ""
								},
								"schema": {
									"properties": {
										"images": {
											"type": "string",
											"description": "A base64 string containing the encoded PNG of the generated image."
										},
										"parameters": {
											"type": "object",
											"description": "Not used. Will be empty."
										},
										"info": {
											"type": "string",
											"description": "Not used. Will be empty."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Generates an image from a text prompt",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/sdapi/v1/img2img": {
			"post": {
				"description": "Transforms an existing image into a new image, guided by a text prompt, and returns a base64 encoded png.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"prompt": "picture of a kobold, high quality HD render",
								"negative_prompt": "ugly, deformed, censored",
								"cfg_scale": 5,
								"steps": 20,
								"width": 512,
								"height": 512,
								"seed": -1,
								"clip_skip": -1,
								"sampler_name": "Euler a",
								"denoising_strength": 0.6,
								"init_images": [],
								"mask": "",
								"inpainting_mask_invert": 0
							},
							"schema": {
								"properties": {
									"prompt": {
										"type": "string"
									},
									"negative_prompt": {
										"type": "string"
									},
									"cfg_scale": {
										"type": "number"
									},
									"steps": {
										"type": "number"
									},
									"width": {
										"type": "number"
									},
									"height": {
										"type": "number"
									},
									"seed": {
										"type": "number"
									},
									"clip_skip": {
										"type": "number"
									},
									"sampler_name": {
										"type": "string"
									},
									"denoising_strength": {
										"type": "number"
									},
									"init_images": {
										"type": "array",
										"items": {
											"type": "string"
										}
									},
									"mask": {
										"type": "string"
									},
									"inpainting_mask_invert": {
										"type": "string"
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"images": [
										"base64_image_data"
									],
									"parameters": {},
									"info": ""
								},
								"schema": {
									"properties": {
										"images": {
											"type": "string",
											"description": "A base64 string containing the encoded PNG of the generated image."
										},
										"parameters": {
											"type": "object",
											"description": "Not used. Will be empty."
										},
										"info": {
											"type": "string",
											"description": "Not used. Will be empty."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Transforms an existing image into a new image",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/sdapi/v1/interrogate": {
			"post": {
				"description": "Generates a short text caption describing an image.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"image": "base64_image_data",
								"model": "clip"
							},
							"schema": {
								"properties": {
									"image": {
										"type": "string",
										"description": "A base64 string containing the encoded PNG of the image."
									},
									"model": {
										"type": "string",
										"description": "Not used."
									}
								},
								"type": "object"
							}
						}
					},
					"required": false
				},
				"responses": {
					"200": {
						"content": {
							"application/json": {
								"example": {
									"caption": "A picture of a white cottage with a flagpole."
								},
								"schema": {
									"properties": {
										"caption": {
											"type": "string",
											"description": "A short text description of the image."
										}
									}
								}
							}
						},
						"description": "Successful request"
					}
				},
				"summary": "Generates a short text caption describing an image",
				"tags": [
					"sdapi/v1"
				]
			}
		},
		"/v1/completions": {
			"post": {
				"summary": "Generates text continuations given a prompt. Please refer to OpenAI documentation",
				"description": "Generates text continuations given a prompt.\n\nThis is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/completions](https://platform.openai.com/docs/api-reference/completions). All KoboldCpp samplers are supported, please refer to /api/v1/generate for more details.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"model": "kcpp",
								"prompt": "Hi, my name is Kobo and",
								"temperature": 0.8,
								"max_tokens": 64
							},
							"schema": {
								"properties": {},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		},
		"/v1/chat/completions": {
			"post": {
				"summary": "Generates a response from a list of messages. Please refer to OpenAI documentation",
				"description": "Given a list of messages comprising a conversation, the model will return a response.\n\n This is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/chat](https://platform.openai.com/docs/api-reference/chat). All KoboldCpp samplers are supported, please refer to /api/v1/generate for more details.",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"model": "kcpp",
								"messages": [
									{
										"role": "system",
										"content": "You are a helpful assistant."
									},
									{
										"role": "user",
										"content": "Tell me a joke about Kobolds."
									}
								],
								"temperature": 0.7
							},
							"schema": {
								"properties": {},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		},
		"/v1/models": {
			"get": {
				"summary": "List and describe the various models available in the API. Please refer to OpenAI documentation",
				"description": "List and describe the various models available in the API.\n\n This is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/models](https://platform.openai.com/docs/api-reference/models)",
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		},
		"/v1/audio/transcriptions": {
			"post": {
				"summary": "Transcribes a wav file with speech to text using loaded Whisper model. Please refer to OpenAI documentation",
				"description": "Transcribes a wav file with speech to text using loaded Whisper model.\n\n This is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/audio/createTranscription](https://platform.openai.com/docs/api-reference/audio/createTranscription)",
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		},
		"/v1/audio/speech": {
			"post": {
				"summary": "Generates Text-To-Speech audio from input text. Please refer to OpenAI documentation",
				"description": "Generates Text-To-Speech audio from input text.\n\n This is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/audio/createSpeech](https://platform.openai.com/docs/api-reference/audio/createSpeech)",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"model": "kcpp",
								"input": "Hello, my name is Kobold and I love to play.",
								"voice": "alloy"
							},
							"schema": {
								"properties": {},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		},
		"/v1/embeddings": {
			"post": {
				"summary": "Creates an embedding vector representing the input text. Please refer to OpenAI documentation",
				"description": "Creates an embedding vector representing the input text.\n\nThis is an OpenAI compatibility endpoint.\n\n Please refer to OpenAI documentation at [https://platform.openai.com/docs/api-reference/embeddings/create](https://platform.openai.com/docs/api-reference/embeddings/create)",
				"requestBody": {
					"content": {
						"application/json": {
							"example": {
								"model": "kcpp",
								"input": "Niko the Kobold is in town today.",
								"truncate": true
							},
							"schema": {
								"properties": {},
								"type": "object"
							}
						}
					},
					"required": true
				},
				"tags": [
					"v1"
				],
				"responses": {
					"default": {
						"description": ""
					}
				}
			}
		}
	},
	"servers": [
		{
			"url": "/"
		}
	],
	"tags": [
		{
			"description": "KoboldAI United compatible API core endpoints",
			"name": "api/v1"
		},
		{
			"description": "Extended API unique to KoboldCpp",
			"name": "api/extra"
		},
		{
			"description": "Common identity API for LLM services",
			"name": "serviceinfo"
		},
		{
			"description": "Image Generation API (A1111 compatible)",
			"name": "sdapi/v1"
		},
		{
			"description": "OpenAI compatible textgen API (not recommended)",
			"name": "v1"
		}
	]
}